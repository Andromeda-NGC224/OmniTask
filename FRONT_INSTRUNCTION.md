## 1. Архитектура и структура проекта

- Компоненты хранятся в `src/components/<ComponentName>` с файлами `Component.tsx`, `types.ts`, `config.ts`, `helpers.ts`, `index.ts`
- Компоненты, специфичные для страницы, — в `pages/PageName/components/<ComponentName>` с той же структурой
- Все компоненты и модули инкапсулируют свою логику и экспортируют наружу только необходимое
- Общие типы — в `src/types/`, специфичные — рядом с компонентом
- Используется `index.ts` для экспорта как в локальных, так и в общих папках
- В `tsconfig.json` прописан `baseUrl: './src'` для кратких импортов

### 2. Типизация

- Строгая типизация включена (`strict`)
- `any` не используется, предпочтение `unknown`
- Всегда используются `interface` для типизации компонентов, даже если ест только один пропс
- Компоненты типизируются с помощью `FC`, импортированого из React
- Типы: `TName`, Интерфейсы: `IName`, Enum: `EName`
- Обобщённые типы применяются, если можно переиспользовать
- Используется `type Nullable<T> = T | null`
- Валидация на рантайме — через `zod`, при необходимости выносится в `types`

### 3. Порядок кода внутри компонентов

Компоненты структурируются строго по логическим блокам, чтобы поддерживать читаемость и предсказуемость.
Начиная с блока состояния, каждый следующий блок отмечается специальным комментарием.

1. **React-хуки**
    - Вызовы `useRouter`, `useParams`, `useTranslation`, `useQuery`, `useUser`, и т.п.
    - Комментарий не ставится

2. **`// ! state`**
    - Всё, что связано с состоянием: `useState`, `useReducer`

3. **`// ! variables`**
    - Производные переменные, полученные из состояния, пропсов, URL и т.п.

4. **`// ! memos`**
    - Использование `useMemo` для расчётов и мемоизации значений

5. **`// ! callbacks`**
    - Мемоизированные функции через `useCallback`, обычно передаваемые в дочерние компоненты или библиотечные хендлеры

6. **`// ! helpers`**
    - Локальные вспомогательные функции, которые не выносятся наружу, но используются в JSX или логике

7. **`// ! handlers`**
    - Обработчики событий, начинающиеся с `handle`: `handleClick`, `handleSubmit`

8. **`// ! effects`**
    - Побочные эффекты: `useEffect`, `useLayoutEffect`, `useUpdateEffect`

9. **`// ! render`**
    - Условные `return`, если компонент должен показать заглушку/ошибку
    - Главный `return` компонента

Каждый блок визуально отделён, идущие комментарии помогают сразу сориентироваться в структуре логики компонента.
- Подкомпоненты выносятся в `components/` папки компонента

### 4. Стилизация

- Используется TailwindCSS, CSS-модули, CSS, SCSS.
- Если используется CSS или SCSS, то соблюдается модульность `Component.module.css`, с `snake_case` классами
- Один стиль на компонент, не смешиваются
- Повторяющиеся стили выносятся предпочтительно в один компонент (`CommonPageWrapper`) или в глобальные стили.
- Глобальные стили не используются в крайнем случае (кроме CSS-переменных)
- Используется `clsx` для динамических классов
- Стили пишутся таким образом, чтобы вёрстка получилась респонсивной. При необходимости используются Tailwind utility-классы или @media
- Все цвета, размеры, шрифты и отступы выносятся в кастомную тему в `tailwind.config.js` или в CSS-переменные в `globals.css`
- Предпочтение отдаётся `rem`, а не `px`

### 5. Хуки и утилиты

- Общие хуки — в `src/hooks/`, если есть вспомогательные файлы — оформляется как модуль
- Локальные хуки — в `ComponentName/hooks/`
- Утилиты — в `src/utils/` по тому же принципу: файл или модуль

### 6. Работа с API

- Все запросы централизованно в `src/api/`
- Используется `axios` через `axios.create()` в `src/httpClient`
- Интерсепторы + refresh token flow
- Ошибки обрабатываются функцией `handleError` — логика показа, разлогина и логирования ошибок
- React Query часто используется для работы с API

### 7. Организация логики и ответственности компонентов

- Компоненты должны быть простыми и тупыми — принимают пропсы и вызывают коллбэки
- Логика запроса, состояния и бизнес-обработки выносится на уровень выше (страница или хук)
- Если JSX перегружен — структура раскладывается на подкомпоненты (`Header`, `Content`, `Footer`) в `components/`
- Хэлперы и логика выносятся в `helpers.ts` или `hooks/`
- Код всегда читается сверху вниз

### 8. Формы и валидация

- Простые формы — через regex
- Сложные — через `zod` или `react-hook-form + zod`
- Схемы хранятся рядом с формой
- Предпочтительный UX: валидация при сабмите, ошибка пропадает при фокусе

### 9. Локализация

- Используется `next-i18next`
- Структура: `public/translations/<lang>/<namespace>.json`
- Примеры: `login.json`, `common.json`
- Использование: `t('some.key')`

### 10. Состояние приложения

- Zustand — основной инструмент для сложного состояния
- Context API — для простого
- Redux Toolkit используется реже
- Всё состояние в `src/store`

### 11. Модалки

- Есть `CommonModal` — обёртка над всеми модалками
- Конкретные модалки (например, `LoginModal`) используют `CommonModal`
- Централизованный менеджер модалок не используется

### 12. Комментарии и документация

- Используются: `// TODO`, `// NOTE`, `// FIXME`, `// REVIEW`
- `JSDoc` применяется для сложных функций или сложнопонимаемых мест
- Документация не генерируется, `README.md` и `CHANGELOG.md` пока не ведутся

### 13. Lazy loading и Error Boundary

- Редкие страницы и компоненты грузятся лениво (`React.lazy`, `next/dynamic`)
- Примеры: terms, profile — lazy; home — нет
- `ErrorBoundary` пока не используется // TODO: внедрить

### 14. Общие принципы и философия

- **Простота важнее “мудрости”** — если можно сделать проще без потери смысла, выбирается простое решение
- **Явное — лучше неявного**: лучше один очевидный экспорт, чем магия
- **Инкапсуляция — ключ**: всё, что относится к модулю, хранится внутри него
- **Гибкость без фанатизма**: нет слепого следования паттернам ради паттернов
- **Стиль ≠ смысл** — Prettier заботится о формате, я — о логике
- **Повторяемость — сила**: если структура одна и та же — меньше когнитивной нагрузки
- **Технический долг фиксится сразу или создаётся `// TODO`**
- **Компоненты не должны знать больше, чем нужно**
- **Код читается сверху вниз, от состояния к отображению**
- **Плохих или лишних вопросов не бывает**
- **Самый плохой вопрос — это тот, который не был задан**
